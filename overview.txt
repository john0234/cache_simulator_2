Project 4 -CISC 340
Kelsey Faulise and Josh Johnson
Simulator: Our simulator works in that it takes in the parameters either by command line or through standard input through the terminal. It then initializes the 2d cache array and setting all of the different parts of the cache. It them class that function that runs the simulator. It class that search cache function, which loops to see if the address is in the cache. If it is not in the cache, it called that memory to cache function which will put the block into the cache. It checks to see if there are any invalid blocks. If there is an invalid block it takes that last block in the cache. If there are no invalid blocks it then takes the last blocks, which is how we implemented our LRU, by making the cache a priority queue. Saying that the block at the first index is the more recently used and the one in the last index is the LRU. It then puts the things addresses into the block and puts this block into the first index and move the others down. It then searches the caches again and returns what way it is in. It then takes the instruction takes the instruction from the cache. It then proceeds down the simulator. I then checks what instruction it is and depending on what the instruction is it will use the cache to either load or store words. Each of the various manipulations with the cache has its own function, such that when a something at a specific memory address, we call the function to go and return what is at the address. There is also a function that takes what is in the registers and puts in back into the cache. This works by taking the memory address and searching the cache to make sure if it is in the cache. If it is not in the cache, it puts it in the cache and then places what is in the registers and puts it into the cache at the correct line within the block. Once the simulator has finished running, which is detected by the halt instruction, and then it frees all of the pointers that have been created to run the simulator. 

Our Difficulties: We had many difficulties during this project. We had an original version of the project that contained four different structs that made up the cache, one that was our cache, one that was our set, one that was our block, and the state struct. We combined all of these to create the cache array, having an array in each of these structures which would allow, or we thought, easy access of the data within. We had all of the logic in place in the program, but when we started to trouble shoot the problems it was realized that the amount of memory that we were using was massive. With the large amount of memory, we ran into many segmentation faults and stack smashing issues. It came to the point where I think that we were overwriting the return address of functions, which was causing massive errors and having random items error out on us.  This in the end, boiled down to the program being unusable. It was then decided that if we didnâ€™t want to turn in the broken file it will need to be re-written. We then quickly rewrote the whole project taking a different approach that would vastly decrease the amount of memory that was used. Also during this process, we took each function step by step and doing extensive testing to make sure that there would be no memory issues and that we would be able to cache the issues before the project was finished and we were backed into a corner. This is how we got to simulator design that we have now. 
